# 영속성 관리 - 내부 동작 방식

## JPA내부 구조

### 영속성 컨텐스트

**JPA에서 가장 중요한 2가지**

- **객체와 관계형 데이터베이스 매핑하기**
- **영속성 컨텍스트**

### 엔티티 매니저 팩토리와 엔티티 매니저  
![image](https://user-images.githubusercontent.com/106207558/220255086-1a8fdb4a-6922-4f6e-b215-b122757b3d24.png)  
### 영속성 컨텍스트


- **“엔티티를 영구 저장하는 환경” 이라는 뜻**
- **EntityManager.persist(entity); (영속성 컨텍스트를 통해서 Entity를 영속화)**
- **정확히는 persist메서드는 DB에 저장한다는게 아니라 Entity를 영속성 컨텍스트라는데 저장하는 것임**

### **엔티티 매니저? 영속성 컨텍스트?**

- **영속성 컨텍스트는 논리적인 개념**
- **눈에 보이지 않는다.**
- **엔티티 매니저를 통해서 영속성 컨텍스트에 접근**

![image](https://user-images.githubusercontent.com/106207558/220255208-ab203c68-13a6-457b-9e72-fdf54f88e0fe.png)  
### **엔티티의 생명주기**

- **비영속 (new/transient)**
    - **영속성 컨텍스트와 전혀 관계가 없는 새로운 상태**
- **영속 (managed)**
    - **영속성 컨텍스트에 관리되는 상태**
- **준영속 (detached)**
    - **영속성 컨텍스트에 저장되었다가 분리된 상태**
- **삭제 (removed)**
    - **삭제된 상태**
    

### 비영속  
![image](https://user-images.githubusercontent.com/106207558/220255368-d65a9a9f-f3a2-45f2-9761-424a1cb66903.png)  
### 영속  
![image](https://user-images.githubusercontent.com/106207558/220255423-f23a257d-7d29-4eb4-9bc3-86ae99645e89.png)  
### 준영속, 삭제  
![image](https://user-images.githubusercontent.com/106207558/220255490-8aa9b3f5-eeb7-4878-8682-aba9ae54259f.png)  
### **영속성 컨텍스트의 이점**

- **1차 캐시**
- **동일성(Identity) 보장**
- **트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)**
- **변경 감지(Dirty Checking)**
- **지연 로딩(lazy Loading)**  
### 엔티티 조회, 1차 캐시  
![image](https://user-images.githubusercontent.com/106207558/220255585-c2742154-ca2d-49e0-bb29-5cb5b6eb7e22.png)  
### 1차 캐시에서 조회  
![image](https://user-images.githubusercontent.com/106207558/220255727-d35115e8-f886-4cf5-a153-2b9d94c03761.png)  
### 데이터베이스에서 조회  
![image](https://user-images.githubusercontent.com/106207558/220255785-b1924e88-1508-4981-b2e8-f0811d2eb034.png)  
### 영속 엔티티의 동일성 보장  
![image](https://user-images.githubusercontent.com/106207558/220255830-0d4a4766-857f-48dd-8597-0e48167a6a89.png)  
### **엔티티 등록**

**트랜잭션을 지원하는 쓰기 지연**

**(자료1)**  
![image](https://user-images.githubusercontent.com/106207558/220255903-a2468303-3c2e-4f62-94d3-4d580714642d.png)  
**(자료2)**  
![image](https://user-images.githubusercontent.com/106207558/220255962-3053aa03-e76a-4f37-9dd2-6b28258e14ed.png)  
**(자료3)**  
![image](https://user-images.githubusercontent.com/106207558/220256155-f9d08dd9-e68f-43e7-8238-58b5b722acb5.png)  
### 엔티티 수정 (변경감지)

**(자료1)**  
![image](https://user-images.githubusercontent.com/106207558/220256228-3e78a198-f1fe-4435-8d78-fc48ab5bc6cb.png)
**(자료2)**  
![image](https://user-images.githubusercontent.com/106207558/220256265-3d71dea0-8eb4-427b-9bd6-7279afc326ed.png)  
### 엔티티 삭제

**//삭제 대상 엔티티 조회**

**Member memberA = em.find(Member.class, “memberA”);**

**em.remove(memberA); //엔티티 삭제**

### **플러시**

**영속성 컨텍스트의 변경내용을 데이터베이스에 반영**

### **플러시 발생 (데이터베이스 트랜잭션이 커밋되면 플러시 자동 발생)**

- **변경 감지**
- **수정된 엔티티 쓰기 지연 SQL저장소에 등록**
- **쓰기 지연 SQL저장소의 쿼리를 데이터베이스에 전송**
    - **(등록,수정,삭제 쿼리)**
    

### **영속성 컨텍스트를 플러시하는 방법**

- **em.flush() - 직접호출**
- **트랜잭션 커밋 - 플러시 자동 호출**
- **JPQL 쿼리 실행 - 플러시 자동 호출**  
![image](https://user-images.githubusercontent.com/106207558/220256331-1e2b182e-7bea-4492-93e4-be0799dcea29.png)  
### **플러시 모드 옵션**

**em.setFlushMode(FlushModeType.COMMIT) 하지만 요거는 쓸일은 없다고 함**

- **FlushModeType.AUTO**
    - **커밋이나 쿼리를 실행할 때 플러시 (기본값)**
- **FlushModeType.COMMIT**
    - **커밋할 때만 플러시**

### **플러시는?**

- **영속성 컨텍스트를 비우지 않음**
- **영속성 컨텍스트의 변경내용을 데이터베이스에 동기화**
- **트랙잭션이라는 작업 단위가 중요 → 커밋 직전에만 동기화하면 됨**

### **준영속 상태**

- **영속 → 준영속**
- **영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)**
- **영속성 컨텍스트가 제공하는 기능을 사용 못함**

### **준영속 상태로 만드는 방법**

- **em.detach(entity)**
    - **특정 엔티티만 준영속 상태로 전환**
- **em.clear()**
    - **영속성 컨텍스트를 완전히 초기화**
- **em.close()**
    - **영속성 컨텍스트를 종료**